package com.imatia.implatform.imatiaspd.model.core.service.impl;

import com.imatia.implatform.imatiaspd.model.core.config.dbrouting.DatabaseContextHolder;
import com.imatia.implatform.imatiaspd.model.core.exception.IdNotExistentOnDBException;
import com.imatia.implatform.imatiaspd.model.core.exception.IdNotPresentException;
import com.imatia.implatform.imatiaspd.model.core.exception.IdPresentException;
import com.imatia.implatform.imatiaspd.model.core.repo.h2.H2Repository;
import com.imatia.implatform.imatiaspd.model.core.service.CRUDService;
import com.imatia.implatform.imatiaspd.model.core.service.domain.h2.H2Entity;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Abstract generic class for services able to do CRUD operations, its purpose is to encapsulate logic used across different services
 *
 * @param <E> the entity type
 * @param <R> the repository type
 */
@Service
@Transactional
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public abstract class AbstractExternalDBsCRUDService<E extends H2Entity, R extends H2Repository<E>> implements CRUDService<E> {
	@Autowired
	@NonNull
	protected R repo;

	@Override
	public E create(final String dbId, final E domainObject) {
		Optional.ofNullable(domainObject.getId()).ifPresent(id -> {
			throw new IdPresentException("Autogenerated ids fields should not be specified at creations");
		});
		E createdValue = repo.save(domainObject);
		DatabaseContextHolder.clear();
		return createdValue;
	}

	@Override
	public Optional<E> read(final String dbId, final Long entityId) {
		DatabaseContextHolder.set(dbId);
		Optional<E> readedValue = repo.findById(entityId);
		DatabaseContextHolder.clear();
		return readedValue;
	}

	//	@Override
	//	public Page<E> find(final String dbId, String search, Pageable pageable) {
	//		ClientDatabaseContextHolder.set(new ClientDatabase(dbId));
	//		Page<E> readedPage = Objects.isNull(search) ?
	//				repo.findAll(pageable) :
	//				repo.findBySubstring(search, pageable);
	//		ClientDatabaseContextHolder.clear();
	//		return readedPage;
	//
	//	}

	@Override
	public void delete(final String dbId, final Long entityId) {
		DatabaseContextHolder.set(dbId);
		if (repo.existsById(entityId)) {
			repo.deleteById(entityId);
			DatabaseContextHolder.clear();
		} else {
			DatabaseContextHolder.clear();
			throw new IdNotExistentOnDBException(this.getClass().getSimpleName(), entityId);
		}
	}

	//	@Override
	//	public Integer delete(final String dbId, final List<Long> entityIds){
	//		ClientDatabaseContextHolder.set(new ClientDatabase(dbId));
	//		Integer deletedId = repo.deleteByIdIn(entityIds);
	//		ClientDatabaseContextHolder.clear();
	//		return deletedId;
	//	}

	@Override
	public E update(final String dbId, final E domainObject) {
		DatabaseContextHolder.set(dbId);
		Boolean doesEntityExists = Optional.ofNullable(domainObject.getId()).map(id -> repo.existsById(id)).orElseThrow(() -> new IdNotPresentException("Id field is mandatory at updates"));
		if (!doesEntityExists) {
			throw new IdNotExistentOnDBException(this.getClass().getSimpleName(), domainObject.getId());
		}

		E updatedObject = repo.save(domainObject);
		DatabaseContextHolder.clear();
		return updatedObject;

	}

	//	protected List<Supplier<String>> getUniquenessValidationSuppliers(DBO dbo){
	//		return Collections.emptyList();
	//	}


}
